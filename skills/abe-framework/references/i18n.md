# 多语言国际化 (i18n)

## 国际化概述

ABE 框架提供了完善的多语言国际化支持，基于 `go-i18n/v2` 库实现，允许开发者轻松地为应用程序添加多语言功能。

## 配置选项

### i18n 配置参数

在 `config.yaml` 中配置多语言支持：

```yaml
i18n:
  default_language: "zh"              # 默认语言
  lang_query_key: "lang"              # 语言查询参数键名
  lang_header: "Accept-Language"      # 语言请求头键名
  message_paths:                      # 翻译文件路径列表
    - "./configs/i18n/locales"
    - "./custom_locales"
```

## 翻译文件管理

### 文件命名规范

翻译文件使用 `active.{language}.yaml` 格式：

- `active.en.yaml` - 英语翻译文件
- `active.zh.yaml` - 中文翻译文件
- `active.ja.yaml` - 日语翻译文件

### 翻译文件结构

```yaml
# active.zh.yaml - 中文翻译文件
# 认证相关
auth:
  missing_header:
    other: "未提供认证信息"
  token_expired:
    other: "令牌已过期"
  invalid_credentials:
    other: "用户名或密码错误"
  unauthorized:
    other: "未授权访问"

# 用户相关
user:
  not_found:
    other: "用户不存在"
  already_exists:
    other: "用户已存在"
  created_success:
    other: "用户创建成功"
  updated_success:
    other: "用户更新成功"
  deleted_success:
    other: "用户删除成功"

# 验证错误
validation:
  required:
    other: "{{.Field}} 是必填项"
  min_length:
    other: "{{.Field}} 长度不能少于 {{.Min}} 个字符"
  max_length:
    other: "{{.Field}} 长度不能超过 {{.Max}} 个字符"
  email:
    other: "{{.Field}} 必须是有效的邮箱地址"
  phone:
    other: "{{.Field}} 必须是有效的手机号码"

# 通用消息
common:
  welcome:
    other: "欢迎 {{.Name}}"
  success:
    other: "操作成功"
  error:
    other: "操作失败"
  not_found:
    other: "资源不存在"
  internal_error:
    other: "服务器内部错误"

# 复数形式支持
messages:
  user_count:
    one: "找到了 1 个用户"
    other: "找到了 {{.Count}} 个用户"
```

```yaml
# active.en.yaml - 英语翻译文件
# Authentication related
auth:
  missing_header:
    other: "No authentication information provided"
  token_expired:
    other: "Token has expired"
  invalid_credentials:
    other: "Invalid username or password"
  unauthorized:
    other: "Unauthorized access"

# User related
user:
  not_found:
    other: "User not found"
  already_exists:
    other: "User already exists"
  created_success:
    other: "User created successfully"
  updated_success:
    other: "User updated successfully"
  deleted_success:
    other: "User deleted successfully"

# Validation errors
validation:
  required:
    other: "{{.Field}} is required"
  min_length:
    other: "{{.Field}} must be at least {{.Min}} characters"
  max_length:
    other: "{{.Field}} must be at most {{.Max}} characters"
  email:
    other: "{{.Field}} must be a valid email address"
  phone:
    other: "{{.Field}} must be a valid phone number"

# Common messages
common:
  welcome:
    other: "Welcome {{.Name}}"
  success:
    other: "Operation successful"
  error:
    other: "Operation failed"
  not_found:
    other: "Resource not found"
  internal_error:
    other: "Internal server error"

# Pluralization support
messages:
  user_count:
    one: "Found 1 user"
    other: "Found {{.Count}} users"
```

## 基本使用方法

### 在控制器中使用翻译

```go
import (
    "github.com/gin-gonic/gin"
    "github.com/nicksnyder/go-i18n/v2/i18n"
    "github.com/otzgo/abe"
)

type UserController struct {
    // ...
}

func (uc *UserController) login(ctx *gin.Context) {
    var req LoginRequest
    if err := ctx.ShouldBindJSON(&req); err != nil {
        // 获取翻译后的错误消息
        errorMsg := abe.Localize(ctx, &i18n.LocalizeConfig{
            MessageID: "validation.required",
            TemplateData: map[string]interface{}{
                "Field": "用户名",
            },
        })
        
        ctx.JSON(400, gin.H{
            "code": 400,
            "msg":  errorMsg,
        })
        return
    }
    
    // 业务逻辑...
    
    // 成功消息
    successMsg := abe.Localize(ctx, &i18n.LocalizeConfig{
        MessageID: "auth.login_success",
        TemplateData: map[string]interface{}{
            "Username": req.Username,
        },
    })
    
    ctx.JSON(200, gin.H{
        "code": 0,
        "msg":  successMsg,
        "data": gin.H{
            "token": token,
        },
    })
}
```

### 获取 Localizer 实例

```go
func (uc *UserController) getUser(ctx *gin.Context) {
    // 获取 Localizer 实例
    localizer := abe.Localizer(ctx)
    if localizer == nil {
        // 如果获取失败，使用默认消息
        ctx.JSON(500, gin.H{"error": "Internal error"})
        return
    }
    
    // 使用 Localizer 进行复杂翻译
    message, err := localizer.Localize(&i18n.LocalizeConfig{
        MessageID: "user.profile",
        TemplateData: map[string]interface{}{
            "Name":     user.Name,
            "Email":    user.Email,
            "JoinDate": user.CreatedAt.Format("2006-01-02"),
        },
        PluralCount: 1,
    })
    
    if err != nil {
        // 翻译失败时的回退处理
        message = fmt.Sprintf("User profile for %s", user.Name)
    }
    
    ctx.JSON(200, gin.H{
        "code": 0,
        "msg":  "success",
        "data": gin.H{
            "profile": message,
        },
    })
}
```

## 语言选择机制

### 语言检测优先级

框架按照以下优先级顺序确定用户的语言偏好：

1. **查询参数** - URL 中的语言参数（默认参数名为 `lang`）
2. **请求头** - HTTP 请求头中的语言设置（默认头为 `Accept-Language`）
3. **默认语言** - 配置中指定的默认语言

### 使用示例

```go
// 1. 通过查询参数指定语言
// GET /api/users?lang=en
// GET /api/users?lang=zh

// 2. 通过请求头指定语言
// Accept-Language: zh-CN,zh;q=0.9,en;q=0.8

// 3. 使用默认语言（配置文件中设置）

func languageSelectionExample(ctx *gin.Context) {
    // 框架会自动处理语言选择
    message := abe.Localize(ctx, &i18n.LocalizeConfig{
        MessageID: "common.welcome",
        TemplateData: map[string]interface{}{
            "Name": "张三",
        },
    })
    
    // 根据用户的语言偏好返回相应语言的消息
    ctx.JSON(200, gin.H{"message": message})
}
```

## 高级翻译功能

### 复数形式处理

```go
// 支持复数形式的翻译
func handleUserList(ctx *gin.Context) {
    users := getUsers() // 假设获取到用户列表
    
    message := abe.Localize(ctx, &i18n.LocalizeConfig{
        MessageID:    "messages.user_count",
        PluralCount:  len(users), // 根据数量选择单复数形式
        TemplateData: map[string]interface{}{
            "Count": len(users),
        },
    })
    
    ctx.JSON(200, gin.H{
        "code": 0,
        "msg":  "success",
        "data": gin.H{
            "users":  users,
            "count":  len(users),
            "notice": message,
        },
    })
}
```

### 条件翻译

```go
func conditionalTranslation(ctx *gin.Context, statusCode int) string {
    var messageId string
    
    switch statusCode {
    case 200:
        messageId = "common.success"
    case 400:
        messageId = "common.bad_request"
    case 401:
        messageId = "auth.unauthorized"
    case 403:
        messageId = "auth.forbidden"
    case 404:
        messageId = "common.not_found"
    case 500:
        messageId = "common.internal_error"
    default:
        messageId = "common.unknown_error"
    }
    
    return abe.Localize(ctx, &i18n.LocalizeConfig{
        MessageID: messageId,
    })
}

// 使用示例
func (uc *UserController) handleResponse(ctx *gin.Context, statusCode int, data interface{}) {
    message := conditionalTranslation(ctx, statusCode)
    
    ctx.JSON(statusCode, gin.H{
        "code": statusCode,
        "msg":  message,
        "data": data,
    })
}
```

### 动态内容翻译

```go
type TranslationService struct {
    bundle *i18n.Bundle
}

func (ts *TranslationService) TranslateError(ctx *gin.Context, errorCode string, params map[string]interface{}) string {
    return abe.Localize(ctx, &i18n.LocalizeConfig{
        MessageID:    fmt.Sprintf("error.%s", errorCode),
        TemplateData: params,
    })
}

func (ts *TranslationService) TranslateSuccess(ctx *gin.Context, action string, entity string) string {
    return abe.Localize(ctx, &i18n.LocalizeConfig{
        MessageID: "success.action_completed",
        TemplateData: map[string]interface{}{
            "Action": action,
            "Entity": entity,
        },
    })
}

// 使用示例
func (uc *UserController) createUser(ctx *gin.Context) {
    // ... 业务逻辑 ...
    
    if err != nil {
        errorMsg := translationService.TranslateError(ctx, "user_creation_failed", map[string]interface{}{
            "Reason": err.Error(),
        })
        ctx.JSON(500, gin.H{"error": errorMsg})
        return
    }
    
    successMsg := translationService.TranslateSuccess(ctx, "创建", "用户")
    ctx.JSON(200, gin.H{"message": successMsg})
}
```

## 自定义翻译文件

### 加载自定义翻译

```go
func loadCustomTranslations(engine *abe.Engine) error {
    // 获取 i18n Bundle
    bundle := engine.I18nBundle()
    
    // 加载自定义翻译文件
    customPaths := []string{
        "./custom_translations/business_messages.zh.yaml",
        "./custom_translations/business_messages.en.yaml",
    }
    
    for _, path := range customPaths {
        if err := loadTranslationFile(bundle, path); err != nil {
            return fmt.Errorf("加载翻译文件失败 %s: %w", path, err)
        }
    }
    
    return nil
}

func loadTranslationFile(bundle *i18n.Bundle, filePath string) error {
    data, err := ioutil.ReadFile(filePath)
    if err != nil {
        return err
    }
    
    _, err = bundle.ParseMessageFileBytes(data, filePath)
    return err
}
```

### 动态添加翻译

```go
func addDynamicTranslations(engine *abe.Engine) {
    bundle := engine.I18nBundle()
    
    // 动态添加翻译消息
    zhMessage := &i18n.Message{
        ID:    "dynamic.feature_enabled",
        Other: "功能 {{.FeatureName}} 已启用",
    }
    
    enMessage := &i18n.Message{
        ID:    "dynamic.feature_enabled",
        Other: "Feature {{.FeatureName}} has been enabled",
    }
    
    bundle.AddMessages(language.Chinese, zhMessage)
    bundle.AddMessages(language.English, enMessage)
}
```

## 最佳实践

### 1. 翻译键名规范

```go
// ✅ 推荐的键名结构
/*
domain.section.key

例如：
- auth.login.failed
- user.profile.updated
- validation.field.required
- common.messages.success
*/

// ❌ 避免的键名
/*
- login_failed          // 缺少命名空间
- user.profile.update.success.msg  // 过于冗长
- 123_invalid          // 使用数字开头
*/
```

### 2. 翻译文件组织

```go
// 推荐的文件组织结构
/*
configs/
└── i18n/
    ├── locales/
    │   ├── active.en.yaml
    │   ├── active.zh.yaml
    │   └── active.ja.yaml
    └── domains/
        ├── auth.en.yaml
        ├── auth.zh.yaml
        ├── user.en.yaml
        ├── user.zh.yaml
        └── common.en.yaml
        └── common.zh.yaml
*/

// 在主程序中加载所有翻译文件
func loadAllTranslations(engine *abe.Engine) {
    bundle := engine.I18nBundle()
    
    // 加载基础翻译
    loadBaseTranslations(bundle)
    
    // 加载领域特定翻译
    loadDomainTranslations(bundle)
    
    // 加载业务特定翻译
    loadBusinessTranslations(bundle)
}
```

### 3. 错误处理和回退

```go
func safeTranslate(ctx *gin.Context, messageId string, fallback string, data map[string]interface{}) string {
    config := &i18n.LocalizeConfig{
        MessageID: messageId,
    }
    
    if data != nil {
        config.TemplateData = data
    }
    
    translated, err := abe.Localize(ctx, config)
    if err != nil || translated == messageId {
        // 翻译失败时使用回退消息
        if data != nil {
            // 简单的模板替换
            translated = simpleTemplateReplace(fallback, data)
        } else {
            translated = fallback
        }
    }
    
    return translated
}

func simpleTemplateReplace(template string, data map[string]interface{}) string {
    result := template
    for key, value := range data {
        placeholder := fmt.Sprintf("{{.%s}}", key)
        result = strings.ReplaceAll(result, placeholder, fmt.Sprintf("%v", value))
    }
    return result
}

// 使用示例
func (uc *UserController) safeResponse(ctx *gin.Context) {
    message := safeTranslate(ctx, 
        "user.operation.success", 
        "操作成功", 
        map[string]interface{}{
            "Operation": "更新",
            "Entity":    "用户",
        })
    
    ctx.JSON(200, gin.H{"message": message})
}
```

### 4. 性能优化

```go
// 缓存常用的翻译消息
type CachedTranslator struct {
    cache map[string]string
    mutex sync.RWMutex
}

func (ct *CachedTranslator) GetTranslatedMessage(ctx *gin.Context, key string) string {
    ct.mutex.RLock()
    if msg, exists := ct.cache[key]; exists {
        ct.mutex.RUnlock()
        return msg
    }
    ct.mutex.RUnlock()
    
    // 获取翻译
    translated := abe.Localize(ctx, &i18n.LocalizeConfig{MessageID: key})
    
    // 缓存结果
    ct.mutex.Lock()
    ct.cache[key] = translated
    ct.mutex.Unlock()
    
    return translated
}

// 预加载常用翻译
func preloadCommonTranslations(engine *abe.Engine) {
    commonKeys := []string{
        "common.success",
        "common.error",
        "common.not_found",
        "auth.unauthorized",
        // ... 其他常用键
    }
    
    bundle := engine.I18nBundle()
    for _, key := range commonKeys {
        // 预编译翻译消息
        bundle.Localize(&i18n.LocalizeConfig{MessageID: key})
    }
}
```

## 测试国际化

### 翻译测试

```go
func TestTranslations(t *testing.T) {
    // 设置测试环境
    setupTestI18n()
    
    tests := []struct {
        name     string
        lang     string
        key      string
        expected string
    }{
        {"中文欢迎消息", "zh", "common.welcome", "欢迎"},
        {"英文欢迎消息", "en", "common.welcome", "Welcome"},
        {"中文错误消息", "zh", "common.error", "操作失败"},
        {"英文错误消息", "en", "common.error", "Operation failed"},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            ctx := createTestContext(tt.lang)
            result := abe.Localize(ctx, &i18n.LocalizeConfig{MessageID: tt.key})
            
            if !strings.Contains(result, tt.expected) {
                t.Errorf("期望包含 '%s'，但得到 '%s'", tt.expected, result)
            }
        })
    }
}

func createTestContext(lang string) *gin.Context {
    ctx, _ := gin.CreateTestContext(httptest.NewRecorder())
    ctx.Request = &http.Request{
        Header: map[string][]string{
            "Accept-Language": {lang},
        },
    }
    return ctx
}
```

## 故障排除

### 常见问题解决

1. **翻译不生效**
   ```go
   // 检查翻译文件是否正确加载
   func debugTranslations(engine *abe.Engine) {
       bundle := engine.I18nBundle()
       
       // 检查支持的语言
       languages := bundle.LanguageTags()
       fmt.Printf("支持的语言: %v\n", languages)
       
       // 检查特定消息是否存在
       message := bundle.MustLocalize(&i18n.LocalizeConfig{
           MessageID: "common.welcome",
       })
       fmt.Printf("翻译结果: %s\n", message)
   }
   ```

2. **语言检测问题**
   ```go
   // 调试语言检测
   func debugLanguageDetection(ctx *gin.Context) {
       acceptLang := ctx.GetHeader("Accept-Language")
       queryLang := ctx.Query("lang")
       
       fmt.Printf("Accept-Language: %s\n", acceptLang)
       fmt.Printf("Query lang: %s\n", queryLang)
       
       // 手动测试语言选择
       localizer := abe.Localizer(ctx)
       if localizer != nil {
           lang := localizer.LanguageTag()
           fmt.Printf("检测到的语言: %s\n", lang)
       }
   }
   ```

3. **模板变量问题**
   ```go
   // 确保模板变量正确传递
   func safeTemplateTranslation(ctx *gin.Context) {
       config := &i18n.LocalizeConfig{
           MessageID: "user.greeting",
           TemplateData: map[string]interface{}{
               "Name":    getUserDisplayName(ctx),
               "Count":   getUserMessageCount(ctx),
               "LastLogin": getLastLoginTime(ctx).Format("2006-01-02 15:04:05"),
           },
       }
       
       message, err := abe.Localize(ctx, config)
       if err != nil {
           // 记录错误并使用备用消息
           log.Printf("翻译错误: %v", err)
           message = "Hello User"
       }
       
       return message
   }
   ```